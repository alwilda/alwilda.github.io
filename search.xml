<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[给github pages设置域名]]></title>
    <url>%2F2019%2F11%2F03%2F%E7%BB%99GithubPages%E8%AE%BE%E7%BD%AE%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[一直使用xxx.github.io总感觉不太合适，域名长且没有个性，所以我们就要为她设置一个独立的域名，首先：我们得先注册一个域名，在哪里注册都无所谓了，其次： （一）添加域名解析 这里我们把记录类型选为CNAME类型，在在记录值中填上你的xxx.github.io,这里需要注意的是不用填http、https、www这些东西。 百度云的解析后面会带个点，属于正常现象。 解析两次，主机记录分别填 WWW 和 @ （二）Github Pages的设置 进入你的仓库，在设置中找到 Custom domain,将你注册的域名填进去，然后，OK]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScprit预编译]]></title>
    <url>%2F2019%2F09%2F13%2FJavaScprit%E9%A2%84%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[创建AO对象 找到形参和变量声明，将变量和形参名作为AO属性名，值为undefined 将实参值和形参统一 在函数体里找到函数声明，值赋予函数体]]></content>
  </entry>
  <entry>
    <title><![CDATA[GitHub Markdown表情代码]]></title>
    <url>%2F2019%2F09%2F13%2FGitHub%20MarkDown%E8%A1%A8%E6%83%85%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[🎁 Emoji cheat sheet for GitHub, Basecamp, Slack &amp; more]]></content>
  </entry>
  <entry>
    <title><![CDATA[pm2常用命令]]></title>
    <url>%2F2019%2F09%2F11%2Fpm2%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一 PM2常用命令假设你现在已经写好了一个app.js的文件，需要启动，你可以使用pm2进行管理 (一) 启动1234# pm2 start app.js# pm2 start app.js --name my-api # my-api为PM2进程名称# pm2 start app.js -i 0 # 根据CPU核数启动进程个数# pm2 start app.js --watch # 实时监控app.js的方式启动，当app.js文件有变动时，pm2会自动 reload (二) 查看进程12# pm2 list# pm2 show 0 或者 # pm2 info 0 # 查看进程详细信息，0为PM2进程id (三) 监控1# pm2 monit (四) 停止12# pm2 stop all # 停止PM2列表中所有的进程# pm2 stop 0 # 停止PM2列表中进程为0的进程 (五) 重载12# pm2 reload all # 重载PM2列表中所有的进程# pm2 reload 0 # 重载PM2列表中进程为0的进程 (六) 重启12# pm2 restart all # 重启PM2列表中所有的进程# pm2 restart 0 # 重启PM2列表中进程为0的进程 (七) 删除PM2进程12# pm2 delete 0 # 删除PM2列表中进程为0的进程# pm2 delete all # 删除PM2列表中所有的进程 (八) 日志操作123# pm2 logs [--raw] # Display all processes logs in streaming# pm2 flush # Empty all log file# pm2 reloadLogs # eload all logs (九) 升级PM212# npm install pm2@lastest -g # 安装最新的PM2版本# pm2 updatePM2 # 升级pm2 (一) 更多命令参数请查看帮助1# pm2 --help 二 PM2目录结构默认的目录是：当前用于的家目录下的.pm2目录（此目录可以自定义，请参考：五、自定义启动文件），详细信息如下： $HOME/.pm2 #will contain all PM2 related files$HOME/.pm2/logs #will contain all applications logs$HOME/.pm2/pids #will contain all applications pids$HOME/.pm2/pm2.log #PM2 logs$HOME/.pm2/pm2.pid #PM2 pid$HOME/.pm2/rpc.sock #Socket file for remote commands$HOME/.pm2/pub.sock #Socket file for publishable events$HOME/.pm2/conf.js #PM2 Configuration 三 自定义启动文件 创建一个test.json的示例文件，格式如下：12345678910111213141516&#123; "apps": &#123; "name": "test", "cwd": "/data/wwwroot/nodejs", "script": "./test.sh", "exec_interpreter": "bash", "min_uptime": "60s", "max_restarts": 30, "exec_mode" : "cluster_mode", "error_file" : "./test-err.log", "out_file": "./test-out.log", "pid_file": "./test.pid" "watch": false &#125;&#125; 说明： apps：json结构，apps是一个数组，每一个数组成员就是对应一个pm2中运行的应用 name：应用程序的名称 cwd：应用程序所在的目录 script：应用程序的脚本路径 exec_interpreter：应用程序的脚本类型，这里使用的shell，默认是nodejs min_uptime：最小运行时间，这里设置的是60s即如果应用程序在60s内退出，pm2会认为程序异常退出，此时触发重启max_restarts设置数量 max_restarts：设置应用程序异常退出重启的次数，默认15次（从0开始计数） exec_mode：应用程序启动模式，这里设置的是cluster_mode（集群），默认是fork error_file：自定义应用程序的错误日志文件 out_file：自定义应用程序日志文件 pid_file：自定义应用程序的pid文件 watch：是否启用监控模式，默认是false。如果设置成true，当应用程序变动时，pm2会自动重载。这里也可以设置你要监控的文件。 详细参数列表：见附件八 四 实例已上面的test.json为例 12345678# cat &gt; /data/wwwroot/nodejs/test.sh &lt;&lt; EOF#!/bin/bashwhile :do echo "Test" &gt;&gt; 1.log sleep 5doneEOF 12# chmod +x test.sh #添加执行权限# pm2 start test.json #启动，如下图： # pm2 list #查看pm2进程，如下图： 五 备注 其他可参数见官网：http://pm2.keymetrics.io 六 附件 Field Type Example Description name string “myAPI” name your app will have in PM2 script string “bin/app.js” path of your app args list [“–enable-logs”, “-n”, “15”] arguments given to your app when it is launched node_args list [“–harmony”, “–max-stack-size=1024”] arguments given to node when it is launched cwd string “/var/www/app/prod” the directory from which your app will be launched exec_mode string “cluster” “fork” mode is used by default, “cluster” mode can be configured with instances field instances number 4 number of instances for your clustered app, 0 means as much instances as you have CPU cores. a negative value means CPU cores - value (e.g -1 on a 4 cores machine will spawn 3 instances) exec_interpreter string “node” defaults to “node”. can be “python”, “ruby”, “bash” or whatever interpreter you wish to use. “none” will execute your app as a binary executable log_date_format string “YYYY-MM-DD HH:mm Z” format in which timestamps will be displayed in the logs error_file string “/var/log/node-app/node-app.stderr.log” path to the specified error log file. PM2 generates one by default if not specified and you can find it by typing pm2 desc &lt;app id&gt; out_file string “/var/log/node-app/node-app.stdout.log” path to the specified output log file. PM2 generates one by default if not specified and you can find it by typing pm2 desc &lt;app id&gt; pid_file string “pids/node-geo-api.pid” path to the specified pid file. PM2 generates one by default if not specified and you can find it by typing pm2 desc &lt;app id&gt; merge_logs boolean false defaults to false. if true, it will merge logs from all instances of the same app into the same file cron_restart string “1 0 * * *” a cron pattern to restart your app. only works in “cluster” mode for now. soon to be avaible in “fork” mode as well watch boolean true enables the watch feature, defaults to “false”. if true, it will restart your app everytime a file change is detected on the folder or subfolder of your app. ignore_watch list [“[\/\\ &#93;\./“, “node_modules”] list of regex to ignore some file or folder names by the watch feature min_uptime number 1000 min uptime of the app to be considered started (i.e. if the app crashes in this time frame, the app will only be restarted the number set in max_restarts (default 15), after that it’s errored) max_restarts number 10 number of consecutive unstable restarts (less than 1sec interval or custom time via min_uptime) before your app is considered errored and stop being max_memory_restart string “150M” your app will be restarted by PM2 if it exceeds the amount of memory specified. human-friendly format : it can be “10M”, “100K”, “2G” and so on… env object {“NODE_ENV”: “production”, “ID”: “42”} env variables which will appear in your app autorestart boolean false true by default. if false, PM2 will not restart your app if it crashes or ends peacefully vizion boolean false true by default. if false, PM2 will start without vizion features (versioning control metadatas) post_update list [“npm install”, “echo launching the app”] a list of commands which will be executed after you perform a Pull/Upgrade operation from Keymetrics dashboard force boolean true defaults to false. if true, you can start the same script several times which is usually not allowed by PM2 next_gen_js boolean true defaults to false. if true, PM2 will launch your app using embedded BabelJS features which means you can run ES6/ES7 javascript code restart_delay number 4000 time to wait before restarting a crashed app (in milliseconds). defaults to 0.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Windows安装nodejs的一些配置]]></title>
    <url>%2F2019%2F08%2F06%2FWindows%E5%AE%89%E8%A3%85nodejs%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Windows安装nodejs一 建立目录 在安装nodejs的目录下新建【node_global】及【node_cache】这两个文件夹 二 配置这啥 打开命令窗口输入：12npm config set prefix "xxx\nodejs\node_global"npm config set cache "xxx\nodejs\node_cache" 三 配置环境变量(一) 系统变量12NODE_PATH: &quot;某盘\nodejs\node_global\node_modules&quot; // 再建一个node_modules目录Path: &quot;某盘\nodejs\&quot; (二) 用户变量1Path: &quot;某盘\nodejs\node_global&quot; 之所以这样配置是因为包被放到了node_global，如果系统变量Path指向 *”xxx\nodejs\node_global”，可node_global并没有nodejs的脚本，故不识别node、npm命令，而在用户变量设置“xxx\nodejs\node_global”*，是为了使用里面包的一些命令。比如俺就是在执行hexo g的时候发现的😂。 四 测试，没必要1npm install express -g # -g是全局安装的意思]]></content>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker的安装与卸载]]></title>
    <url>%2F2019%2F08%2F02%2Fdocker%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[修改为阿里yum源-mirrors.aliyun.com 一 安装docker Docker 要求 CentOS 系统的内核版本高于 3.10,通过 uname -r 命令查看你当前的内核版本 使用 root 权限登录 Centos。确保 yum 包更新到最新。 1sudo yum update 卸载旧版本(如果安装过旧版本的话) 查看卸载办法 安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 #yum 配置管理工具 设置yum源 1234567891011121314sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo或者 清华大学的 Docker 安装源sudo yum-config-manager --add-repo https://mydream.ink/utils/container/docker-ce.repo报错：adding repo from: https://mydream.ink/utils/container/docker-ce.repo grabbing file https://mydream.ink/utils/container/docker-ce.repo to /etc/yum.repos.d/docker-ce.repo Could not fetch/save url https://mydream.ink/utils/container/docker-ce.repo to file /etc/yum.repos.d/docker-ce.repo: [Errno 14] curl #60 - "Peer's Certificate has expired."出现该问题一般是由于本地时间不正确（经常挂起的虚拟机很容易出现），使用date命令核对一下时间即可，若确认是这个问题，则：sudo ntpdate pool.ntp.org # ntpdate 可使用 yum install ntpdate 进行安装 安装最新版的 Docker CE 1sudo yum install docker-ce docker-ce-cli containerd.io 镜像加速 新建或修改 /etc/docker/daemon.json ，加入： 123456&#123; "registry-mirrors": [ "https://dockerhub.azk8s.cn", "https://reg-mirror.qiniu.com" ]&#125; 一定要确保格式没有问题，否则 docker 无法启动，修改完成后执行以下命令：1sudo systemctl daemon-reload 启动并加入开机启动 12sudo systemctl start docker # 启动sudo systemctl enable docker # 开机启动 验证安装是否成功(有client和service两部分表示docker安装启动都成功了) 1docker version 二 卸载docker12345678910111213141516yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-enginerm -rf /etc/systemd/system/docker.service.drm -rf /var/lib/dockerrm -rf /var/run/docker 三 docker启动、重启、关闭命令 作用 命令 启动 systemctl start docker 守护进程重启 sudo systemctl daemon-reload 重启docker服务 systemctl restart docker 重启docker服务 sudo service docker restart 关闭docker service docker stop 关闭docker systemctl stop docker]]></content>
  </entry>
  <entry>
    <title><![CDATA[docker安装并使用MySQL57]]></title>
    <url>%2F2019%2F08%2F02%2Fdocker%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8MySQL57%2F</url>
    <content type="text"><![CDATA[一 下载MySQL571docker pull mysql:5.7 二 启动 后台启动并设置端口号，把数据库具体的数据放在本机而不是容器内部 1docker run -p 3306:3306 --name docker-mysql -v /root/docker/mysql57/conf:/etc/mysql/conf.d -v /root/docker/mysql57/logs:/logs -v /root/docker/mysql57/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7 三 从docker进入MySQL，没必要123docker exec -it docker-mysql bashmysql -u root -p]]></content>
  </entry>
  <entry>
    <title><![CDATA[maven settings.xml]]></title>
    <url>%2F2019%2F08%2F02%2Fmaven%20settings.xml%2F</url>
    <content type="text"><![CDATA[仅以此文来保存我的配置 一 位置1&lt;localRepository&gt;E:/MavenStore&lt;/localRepository&gt; 二 镜像1234567&lt;!-- 阿里云镜像 --&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 三 编码格式与jdk版本1234567891011121314151617181920212223242526272829&lt;!-- 接上面的&lt;profiles&gt;标签 --&gt; &lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;!-- 下载源码包 --&gt; &lt;profile&gt; &lt;id&gt;downloadSources&lt;/id&gt; &lt;properties&gt; &lt;downloadSources&gt;true&lt;/downloadSources&gt; &lt;downloadJavadocs&gt;true&lt;/downloadJavadocs&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; &lt;!-- !!! --&gt; &lt;activeProfiles&gt; &lt;activeProfile&gt;downloadSources&lt;/activeProfile&gt;&lt;/activeProfiles&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[修改为阿里yum源-mirrors.aliyun.com]]></title>
    <url>%2F2019%2F08%2F01%2F%E4%BF%AE%E6%94%B9%E4%B8%BA%E9%98%BF%E9%87%8Cyum%E6%BA%90-mirrors.aliyun.com%2F</url>
    <content type="text"><![CDATA[一 修改为阿里yum源 -mirrors.aliyun.com## (一) 首先备份系统自带yum源配置文件/etc/yum.repos.d/CentOS-Base.repo 1[root@localhost ~]# mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup (二) 查看CentOS系统版本1[root@localhost ~]# lsb_release -a (三) 下载ailiyun的yum源配置文件到/etc/yum.repos.d/1234567891011CentOS7[root@localhost ~]# wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repoCentOS6[root@localhost ~]# wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repoCentOS5[root@localhost ~]# wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-5.repo ## (四) 运行yum makecache生成缓存 1[root@localhost ~]# yum makecache (五) 这时候再更新系统就会看到以下mirrors.aliyun.com信息123456[root@localhost ~]# yum -y update已加载插件：fastestmirror, refresh-packagekit, security设置更新进程Loading mirror speeds from cached hostfile* base: mirrors.aliyun.com* extras: mirrors.aliyun.com* updates: mirrors.aliyun.com]]></content>
  </entry>
  <entry>
    <title><![CDATA[java项目git忽略配置]]></title>
    <url>%2F2019%2F07%2F13%2Fjava%E9%A1%B9%E7%9B%AEgit%E5%BF%BD%E7%95%A5%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[实际上是从 https://start.spring.io/ 上的 .gitignore文件而来… 12345678910111213141516171819202122232425262728293031HELP.mdtarget/!.mvn/wrapper/maven-wrapper.jar!**/src/main/**!**/src/test/**### STS/eclipse ###.apt_generated.classpath.factorypath.project.settings.springBeans.sts4-cache### IntelliJ IDEA ###.idea*.iws*.iml*.ipr### NetBeans ###/nbproject/private//nbbuild//dist//nbdist//.nb-gradle/build/### VS Code ###.vscode/]]></content>
  </entry>
  <entry>
    <title><![CDATA[SSM整合里的一些配置]]></title>
    <url>%2F2019%2F07%2F13%2FSSM%E6%95%B4%E5%90%88%E9%87%8C%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[注意 是SPRING MYBATIS SPRINGMVC 一 pom.xml和web.xml(一) pom.xml 记录一下这个神秘代码，否则用的时候到处找还找不到1234567891011&lt;!-- pom.xml --&gt;&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;!-- 文件拷贝时的编码 --&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;!-- 编译时的编码 --&gt; &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt;&lt;/properties&gt; (二) web.xml 这个web.xml使用4.0的，eclipse和idea生成maven项目web.xml都是2.x的版本，不好，不好。12345678910111213141516171819202122232425262728293031323334353637383940414243444546 &lt;!-- web.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" id="WebApp_ID" version="4.0"&gt; &lt;display-name&gt;springjson&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- dispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 编码格式UTF-8 --&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 二 spring篇(一) 将controller层加入component-scan的黑名单 controller层扫描xxx.xxx.controller,其他包来个 xxx.xxx.*，这样就有点重复，所以在通配那里将controller层加入黑名单123&lt;context:component-scan base-package="xxx.xxx.*" use-default-filters="false"&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt;&lt;/context:component-scan&gt; 三 mybatis篇(一) spring管理mybatis1. spring xml的配置12345678910111213141516171819202122232425&lt;!-- 数据库连接 --&gt;&lt;!-- &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; --&gt;&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt; &lt;property name="driverClassName" value="$&#123;driver&#125;"&gt;&lt;/property&gt; &lt;property name="url" value="$&#123;url&#125;"&gt;&lt;/property&gt; &lt;property name="username" value="$&#123;username&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;password&#125;"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 管理MyBatis --&gt;&lt;bean class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml"&gt;&lt;/property&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;property name="mapperLocations"&gt; &lt;array&gt; &lt;value&gt;classpath:com/xxx/mapper/*.xml&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name="typeAliasesPackage" value="com.xxx.entity"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 管理mapper层接口 --&gt;&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.xxx.mapper"&gt;&lt;/property&gt;&lt;/bean&gt; 2. 本身的mybatis-config.xml就配置一下log4j12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name="logImpl" value="LOG4j" /&gt; &lt;/settings&gt; &lt;!-- &lt;plugins&gt; &lt;plugin interceptor="com.github.pagehelper.PageInterceptor"&gt;&lt;/plugin&gt; &lt;/plugins&gt; --&gt;&lt;/configuration&gt; 3. log4j123456log4j.rootLogger=error, Console log4j.logger.com.xxx.mapper=debug #Consolelog4j.appender.Console=org.apache.log4j.ConsoleAppender log4j.appender.Console.layout=org.apache.log4j.PatternLayout log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Office2019激活方法]]></title>
    <url>%2F2019%2F07%2F09%2Foffice2019%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[专业增强版（批量版）的激活方式 复制以下代码到bat文件，以管理员模式运行，等待几分钟就好了 1234567891011121314@echo off(cd /d "%~dp0")&amp;&amp;(NET FILE||(powershell start-process -FilePath '%0' -verb runas)&amp;&amp;(exit /B)) &gt;NUL 2&gt;&amp;1title Office 2019 Activator r/Piracyecho Converting... &amp; mode 40,25(if exist "%ProgramFiles%\Microsoft Office\Office16\ospp.vbs" cd /d "%ProgramFiles%\Microsoft Office\Office16")&amp;(if exist "%ProgramFiles(x86)%\Microsoft Office\Office16\ospp.vbs" cd /d "%ProgramFiles(x86)%\Microsoft Office\Office16")&amp;(for /f %%x in ('dir /b ..\root\Licenses16\ProPlus2019VL*.xrm-ms') do cscript ospp.vbs /inslic:"..\root\Licenses16\%%x" &gt;nul)&amp;(for /f %%x in ('dir /b ..\root\Licenses16\ProPlus2019VL*.xrm-ms') do cscript ospp.vbs /inslic:"..\root\Licenses16\%%x" &gt;nul)cscript //nologo ospp.vbs /unpkey:6MWKP &gt;nul&amp;cscript //nologo ospp.vbs /inpkey:NMMKJ-6RK4F-KMJVX-8D9MJ-6MWKP &gt;nul&amp;set i=1:serverif %i%==1 set KMS_Sev=kms7.MSGuides.comif %i%==2 set KMS_Sev=kms8.MSGuides.comif %i%==3 set KMS_Sev=kms9.MSGuides.comcscript //nologo ospp.vbs /sethst:%KMS_Sev% &gt;nulecho %KMS_Sev% &amp; echo Activating...cscript //nologo ospp.vbs /act | find /i "successful" &amp;&amp; (echo Complete) || (echo Trying another KMS Server &amp; set /a i+=1 &amp; goto server)pause &gt;nul 到office安装目录，例如 C:\Program Files\Microsoft Office\Office16 以管理员身份打开Windows PowerShell运行以下命令即可查看office到期时间1cscript ospp.vbs /dstatus REMAINING GRACE一行表示激活剩余天数（以及剩余分钟数）。 Activation Type Configuration一行的意思是“激活类型”。当然了，如果你不是使用KMS激活也就无需操心这个剩余天数了。]]></content>
      <tags>
        <tag>office</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring AOP]]></title>
    <url>%2F2019%2F07%2F07%2FSpring%20AOP%2F</url>
    <content type="text"><![CDATA[一 SpringAOP简介：面向切面编程（Aspect Oriented Programming）提供了另一种角度来思考程序的结构，通过这种方式弥补面向对象编程(Object Oriented Programming)的不足。除了类以外，AOP提供了切面，切面对关注点进行模块化，例如横切多个类型和对象的事务管理（这些关注点术语通常称作横切(crosscutting)关注点）。Spring AOP是Spring的一个重要组件，但是Spring IOC并不依赖于Spring AOP，这意味着你可以自由选择是否使用AOP，AOP提供了强大的中间件解决方案，这使得Spring IOC更加完善。我们可以通过AOP来实现日志监听，事务管理，权限控制等等。 二 AOP概念： 切面（Aspect）：一个关注点的模块化，这个关注点可能会横切多个对象。事务管理是Java应用程序中一个关于横切关注点的很好的例子。在Spring AOP中，切面可以使用通过类（基于模式（XML）的风格）或者在普通类中以@Aspect注解（AspectJ风格）来实现。 连接点（Join point）：程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候。在Spring AOP中一个连接点总是代表一个方法的执行。说人话就是AOP拦截到的方法就是一个连接点。通过声明一个org.aspectj.lang.JoinPoint类型参数我们可以在通知(Advice)中获得连接点的信息。这个在稍后会给出案例。 通知(Advice)：在切面（Aspect）的某个特定连接点上（Join point）执行的动作。通知的类型包括”around”，”before”，”after”等等。通知的类型将在后面进行讨论。许多AOP框架，包括Spring 都是以拦截器作为通知的模型，并维护一个以连接点为中心的拦截器链。总之就是AOP对连接点的处理通过通知来执行。个人理解：Advice指当一个方法被AOP拦截到的时候要执行的代码。切入点（Pointcut）：匹配连接点（Join point）的断言。通知（Advice）跟切入点表达式关联，并在与切入点匹配的任何连接点上面运行。切入点表达式如何跟连接点匹配是AOP的核心，Spring默认使用AspectJ作为切入点语法。个人理解：通过切入点的表达式来确定哪些方法要被AOP拦截，之后这些被拦截的方法会执行相对应的Advice代码。 引入（Introduction）：声明额外的方法或字段。Spring AOP允许你向任何被通知(Advice)对象引入一个新的接口（及其实现类）。个人理解：AOP允许在运行时动态的向代理对象实现新的接口来完成一些额外的功能并且不影响现有对象的功能。 目标对象（Target object）：被一个或多个切面（Aspect）所通知（Advice）的对象，也称作被通知对象。由于Spring AOP是通过运行时代理实现的，所以这个对象永远是被代理对象。个人理解：所有的对象在AOP中都会生成一个代理类，AOP整个过程都是针对代理类在进行处理。 AOP代理（AOP proxy）：AOP框架创建的对象，用来实现切面契约（aspect contract）（包括通知方法执行等功能），在Spring中AOP可以是JDK动态代理或者是CGLIB代理。织入（Weaving）：把切面（aspect）连接到其他的应用程序类型或者对象上，并创建一个被通知对象。这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。Spring和其他纯AOP框架一样，在运行时完成织入。个人理解：把切面跟对象关联并创建该对象的代理对象的过程。 三 通知(Advice)的类型： 前置通知（Before advice）：在某个连接点（Join point）之前执行的通知，但这个通知不能阻止连接点的执行（除非它抛出一个异常）。 返回后通知（After returning advice）：在某个连接点（Join point）正常完成后执行的通知。例如，一个方法没有抛出任何异常正常返回。 抛出异常后通知（After throwing advice）：在方法抛出异常后执行的通知。 后置通知（After（finally）advice）：当某个连接点（Join point）退出的时候执行的通知（不论是正常返回还是发生异常退出）。 环绕通知（Around advice）：包围一个连接点（Join point）的通知，如方法调用。这是最强大的一种通知类型。环绕通知可以在方法前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。 四 流程图 五 实现AOP的方法(一) 基于xml的实现 bean交给IOC容器，xml或注解 1. 前置通知12345678910111213141516import java.lang.reflect.Method;import org.springframework.aop.MethodBeforeAdvice;public class DemoBefore implements MethodBeforeAdvice&#123; @Override public void before(Method method, Object[] args, Object target) throws Throwable &#123; System.out.println("前置"); &#125;&#125;&lt;!-- xml --&gt;&lt;aop:config&gt; &lt;aop:pointcut expression='execution(public String priv.lyq.aop.Fun.add(String))' id="pointcut1"/&gt; &lt;aop:advisor advice-ref="demoBefore" pointcut-ref="pointcut1"/&gt; &lt;/aop:config&gt; 2. 返回后通知12345678910111213141516171819import java.lang.reflect.Method;import java.util.Arrays;import org.springframework.aop.AfterReturningAdvice;import org.springframework.stereotype.Component;@Componentpublic class DemoAfterReturning implements AfterReturningAdvice&#123; @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123; System.out.println("后置通知。" + "返回值：" + returnValue + "\t方法名：" + method.getName() + "\t参数：" +Arrays.toString(args) + "\t" + target); &#125;&#125;&lt;!-- xml --&gt;&lt;aop:config&gt; &lt;aop:pointcut expression='execution(public String priv.lyq.aop.Fun.add(String))' id="pointcut2"/&gt; &lt;aop:advisor advice-ref="demoAfterReturning" pointcut-ref="pointcut2"/&gt; &lt;/aop:config&gt; 3. 抛出异常后通知123456789101112131415161718import java.lang.reflect.Method;import org.springframework.aop.ThrowsAdvice;import org.springframework.stereotype.Component;@Componentpublic class DemoException implements ThrowsAdvice &#123; public void afterThrowing(Method method, Object[] args, Object target, Throwable ex) &#123; System.out.println("异常通知" + "\t" + method.getName() + "\t" + ex.getMessage()); &#125;&#125;&lt;!-- xml --&gt;&lt;aop:config&gt; &lt;aop:pointcut expression='execution(public String priv.lyq.aop.Fun.add(String))' id="pointcut3"/&gt; &lt;aop:advisor advice-ref="demoException" pointcut-ref="pointcut3"/&gt; &lt;/aop:config&gt; 4. 环绕通知1234567891011121314151617181920212223242526import org.aopalliance.intercept.MethodInterceptor;import org.aopalliance.intercept.MethodInvocation;import org.springframework.stereotype.Component;@Componentpublic class DemoAround implements MethodInterceptor&#123; @Override public Object invoke(MethodInvocation invocation) throws Throwable &#123; Object result = null; try &#123; System.out.println("环绕通知之前置通知"); result = invocation.proceed(); // 控制着目标方法的执行，上面是前置下面是后置，catch块是异常通知 System.out.println("环绕通知之后置通知" + "目标对象:" + invocation.getThis() + "调用的方法名：" + invocation.getMethod().getName() + "返回值：" + result); &#125; catch (Exception e) &#123; System.out.println("环绕通知的异常通知"); &#125; return result; &#125;&#125;&lt;!-- xml --&gt;&lt;aop:config&gt; &lt;aop:pointcut expression='execution(public String priv.lyq.aop.Fun.add(String))' id="pointcut4"/&gt; &lt;aop:advisor advice-ref="demoAround" pointcut-ref="pointcut4"/&gt; &lt;/aop:config&gt; (二) 基于注解的实现六 一些参数、配置的解释(一) expression=” “ aop:pointcut”标签中”expression”的写法规则如下： execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?)ret-type-pattern,name-pattern(param-pattern)是必须的. ret-type-pattern:标识方法的返回值，需要使用全路径的类名如java.lang.String,也可以为*表示任何返回值； name-pattern:指定方法名,代表所有,例如set,代表以set开头的所有方法. param-pattern:指定方法参数(声明的类型),(..)代表所有参数,()代表一个参数,(,String)代表第一个参数为任何值,第二个为String类型. 表达式例子如下： 任意公共方法的执行： execution(public * *(..)) 任何一个以“set”开始的方法的执行： execution(* set*(..)) AccountService 接口的任意方法的执行： execution(* com.xyz.service.AccountService.*(..)) 定义在service包里的任意方法的执行： execution(* com.xyz.service..(..)) 定义在service包和所有子包里的任意类的任意方法的执行： execution(* com.xyz.service...(..)) 定义在pointcutexp包和所有子包里的JoinPointObjP2类的任意方法的执行： execution(* com.test.spring.aop.pointcutexp..JoinPointObjP2.*(..))”) 在多个表达式之间使用 ||,or表示 或，使用 &amp;&amp;,and表示 与，！表示 非.例如： 1234&lt;aop:config&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;(execution(* com.ccboy.dao..*.find*(..))) or (execution(* com.ccboy.dao..*.query*(..)))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;jdbcInterceptor&quot; pointcut-ref=&quot;pointcut&quot; /&gt; &lt;/aop:config&gt; (二) JoinPoint 对象 JoinPoint对象封装了SpringAop中切面方法的信息,在切面方法中添加JoinPoint参数,就可以获取到封装了该方法信息的JoinPoint对象.常用api: 方法名 功能 Signature getSignature(); 获取封装了署名信息的对象,在该对象中可以获取到目标方法名,所属类的Class等信息 Object[] getArgs(); 获取传入目标方法的参数对象 Object getTarget(); 获取被代理的对象 Object getThis(); 获取代理对象 2. ProceedingJoinPoint对象是JoinPoint的子接口,该对象只用在@Around的切面方法中, 添加了: + Object proceed() throws Throwable //执行目标方法 + Object proceed(Object[] var1) throws Throwable //传入的新的参数去执行目标方法两个方法.]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea配置tomcat以及运行普通web项目]]></title>
    <url>%2F2019%2F07%2F07%2Fidea%E9%85%8D%E7%BD%AEtomcat%E4%BB%A5%E5%8F%8A%E8%BF%90%E8%A1%8C%E6%99%AE%E9%80%9Aweb%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[Tomcat的配置1. 在主界面打开设置 2. 选择Application Servers后点击 + 加号，选择Tomcat Server 3. 选择tomcat的路径 配置成功。 运行普通web项目控制台乱码问题的解决办法 设置idea的默认项目编码 配置项目中tomcat的编码 打开项目界面右上方选择TomCat再选择修改 在VM options填写-Dfile.encoding=UTF-8 要是还不行就修改idea的一些配置文件 打开idea安装目录下的bin文件夹 打开idea.exe.vmoptions和idea64.exe.vmoptions文件 添加 -Dfile.encoding=UTF-8]]></content>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode插件系列]]></title>
    <url>%2F2019%2F07%2F07%2Fvscode%E6%8F%92%E4%BB%B6%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[必备插件 已经安装的 Auto Rename Tag，非常实用！要修改标签名称的时候自动修改结束标签，节省一半时间，提升效率，非常棒！ Chinese (Simplified) Language Pack for Visual Studio Code 适用于 VS Code 的中文（简体）语言包 ESLint HTML CSS Support，在编写样式表的时候，自动补全功能大大缩减了编写时间，推荐！ HTML Snippets，这款插件包含html标签，非常全，很实用； vscode-icons，这款必须要推荐，明显提升效率的小插件，在项目文件多类型多的情况下，找到制定文件会大大缩短时间； JavaScript Snippet Pack，针对js的插件，包含了js的常用语法关键字，很实用； jQuery Code Snippets：juqery提示插件 open in brower 在浏览器中运行 Path Intellisense：自动路劲补全，默认不带这个功能的，赶紧装 Markdown TOC 生成目录 找到文件的Eol可以看到默认行尾字符设置为auto。 Markdown PDF Markdown生成PDF(在setting.json设置一下chrome的路径)1&quot;markdown-pdf.executablePath&quot;: &quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe&quot; 尚未安装的 Class autocomplete for HTML，编写html代码的朋友们对html代码的一大体现就是重复，如果纯用手敲不仅累还会影响项目进度，这款自动补全插件真的很棒； beautify，这款类似于vscode里格式化代码的功能，不错； Emoji，很好玩的一款插件，可以在代码中插入emoji了，也许是程序猿的娱乐方式吧； Can I Use，自动检测所写代码能否在相应容器正常编译执行； Auto Close Tag，编写html代码的时候，写完开始标签，这款插件会自动补全结束标签，其实上面所说的html自动补全插件一个Tab就搞定了，不过有时也需要这款插件； Debugger for Chrome：让 vscode 映射 chrome 的 debug功能，静态页面都可以用 vscode 来打断点调试。 Debugger for Firefox，在Firefox浏览器中调试。 Import Cost 引入包大小计算,对于项目打包后体积掌握很有帮助 附录 vscode插件推荐。 修改自动生成html的基本标签 路径1C:\Users\75536\AppData\Local\Programs\Microsoft VS Code\resources\app\extensions\emmet\node_modules\vscode-emmet-helper\out\expand\expand-full.js]]></content>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea常用快捷键]]></title>
    <url>%2F2019%2F07%2F07%2Fidea%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[一 生成foreach或者loop 快捷键 iter Iterate (for each..in) itin Iterate (for..in) itli Iterate over a List itar Iterate elements of array ritar Iterate elements of array in reverse order 二 生成返回值对象 Ctrl + Alt + V 三 try catch Ctrl + Alt + T Shift + Alt + Z 四 导入未实现的方法,强制类型转换 Alt + Enter （在语句里执行）]]></content>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC入门]]></title>
    <url>%2F2019%2F06%2F30%2FSpringMVC%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[一 SpringMVC流程(一) 什么是MVC模式 MVC是一种设计模式 M-Model 模型（完成业务逻辑：有javaBean构成，service+dao+entity） V-View 视图（做界面的展示 jsp，html……） C-Controller 控制器（接收请求—&gt;调用模型—&gt;根据结果派发页面） (二) 流程叙述 用户发送请求至前端控制器DispatcherServlet。 DispatcherServlet收到请求调用HandlerMapping处理器映射器。 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 DispatcherServlet调用HandlerAdapter处理器适配器。 HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 Controller执行完成返回ModelAndView。 HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 ViewReslover解析后返回具体View。 DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 DispatcherServlet响应用户。 二 Web项目启动加载配置文件(一) xml配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" id="WebApp_ID" version="4.0"&gt; &lt;display-name&gt;xxx&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- &amp;lt;!&amp;ndash; 非SpringMVC项目加载配置文件 &amp;ndash;&amp;gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:applicationContext.xml &lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &amp;lt;!&amp;ndash; 此监听器在服务器启动丝毫初始化IOC容器 &amp;ndash;&amp;gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; --&gt; &lt;servlet&gt; &lt;!-- 如果没有写加载xml的初始化参数的话 这个servlet-name叫springmvc，则SpringMVC会自动加载WEB-INF下springmvc-servlet.xml, 如果换作其他名字比如叫dispatcherServlet,则会加载dispatcherServlet-servlet.xml --&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; (二) classpath 和 classpath* 的区别 一般classpath指向的是classes，也就是编译路径的根路径，而一般classes中放着这些文件:1.java文件编译好的class文件。2.properties配置文件。3.xml配置文件。4.一些模版文件，如*.ftl。5.其他需要用classpath获取到的文件。 classpath：只会到你指定的class路径中查找文件; classpath*：不仅包含class路径，还包括jar文件中(class路径)进行查找。 三 配置视图解析器1234&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt;&lt;/bean&gt; 四 @RequestMapping注解(一) 属性解释 @RequestMapping(‘xxx’) 默认不加任何属性,为请求的路径，可以加到类上。 1. method 设置请求的方式1method = &#123;RequestMethod.GET,RequestMethod.POST&#125; 2. params 请求的参数的设置1234params = &#123;&quot;name&quot;&#125; // 请求参数必须包含 nameparams = &#123;&quot;name=abc&quot;&#125; // 请求参数name必须等于abcparams = &#123;&quot;age!=18&quot;&#125; // 请求参数age的值不能是18params = &#123;&quot;!gender&quot;&#125; // 请求参数不能有 gender 3. headers 请求头信息的设置1headers = &#123;&#125; (二) Ant风格的请求路径1. 什么是Ant风格 通配符 说明 ? 匹配任何单字符 * 匹配0或者任意数量的字符 ** 匹配0或者更多的目录 2. 通配符*任意字符 123@RequestMapping(value = "s1/*/get1")&lt;a href="$&#123;pageContext.request.contextPath&#125;/s1/abcdefg/get1?msg=common"&gt;*通配符&lt;/a&gt; 3. 通配符**任意目录 123@RequestMapping(value = "s2/**/get2")&lt;a href="$&#123;pageContext.request.contextPath&#125;/s2/a/b/c/get2?msg=common"&gt;**通配符&lt;/a&gt; (三) @PathVariable接受动态参数123456@RequestMapping(value = "s3/*/get3/&#123;name&#125;", method = &#123;RequestMethod.GET&#125;) public String get2(@PathVariable("name") String name) &#123; System.out.println(name); return "success.jsp"; &#125; // name = "antStyle" 1&lt;a href="$&#123;pageContext.request.contextPath&#125;/s3/abc/get3/antStyle"&gt;ant传&lt;/a&gt; 五 Result风格(一) 过滤的条件 &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete/put&quot; /&gt; 请求方式是POST (二) web.xml的配置123456789&lt;!-- Result风格 过滤器配置 --&gt;&lt;filter&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; (三) 实例 input标签value值必须是大写 12345@RequestMapping(value = "test/&#123;id&#125;", method = &#123;RequestMethod.DELETE&#125;)public String delete(@PathVariable("id") String id) &#123; System.out.println(id); return "success.jsp";&#125; 1234&lt;form action="" method="post"&gt; &lt;input type="hidden" name="_method" value="DELETE" /&gt; &lt;input type="submit" value="删除" /&gt;&lt;/form&gt; PUT同理 当映射名称都相同时，可以通过不同的Method指定不同的请求 六 数据接收的几种方式(一) 表单数据与后台方法形参对应 适用于get方式提交，不适用于post方式提交。 参数name值名最好和后台形参名保持一致。 123456@RequestMapping("/addUser1")public String addUser1(String username,String password) &#123; System.out.println("username is:"+username); System.out.println("password is:"+password); return "xxx";&#125; 12345&lt;form method="GET" action="addUser1"&gt; 用户名：&lt;input type="text" name="username" /&gt; 密码：&lt;input type="password" name="password" /&gt; &lt;input type="submit " value="提交" /&gt;&lt;/form&gt; 1. @RequestParam注解这个也可算是一种新的接收方式 可以对传入参数指定参数名。 可以通过required=false或者true来要求@RequestParam配置的前端参数是否一定要传。 如果@requestParam注解的参数是int类型，并且required=false，此时如果不传参数的话，会报错。原因是，required=false时，不传参数的话，会给参数赋值null，这样就会把null赋值给了int，因此会报错。 defaultValue=”” 设置默认值。 (二) 通过HttpServletRequest接收不再赘述 (三) 通过JavaBean(实体类)接收 支持级联。比如： 123456789101112131415public class User &#123; private String username; private String password; private Address address;&#125;public class Address &#123; private Integer addressId; private Integer userId; private String username; private String province; private String city; private String county; private String address; private String tel;&#125; 1&lt;input type="text" name="address.province" /&gt; (四) @PathVariable接受动态参数上面已经解释，点击查看 (五) 使用@ModelAttribute注解获取POST请求的FORM表单数据123456789101112 @ModelAttributepublic void getAccount(Map&lt;String, Account&gt; map) &#123; Account account = new Account(1, "jack", 25.0); map.put("account", account); // map的key就是方法参数类型的首字母小写 System.out.println("getAccount" + account);&#125;@RequestMapping(value = "updateAccount", method = RequestMethod.POST)public ModelAndView updateAccount(@ModelAttribute("acc") Account account) &#123; ModelAndView mv = new ModelAndView(""); return null;&#125; 如果map的key和方法参数类型的首字母小写不一致，则用@ModelAttribute(“acc”)注解保持一致 123456&lt;form action="$&#123;pageContext.request.contextPath&#125;/model/updateAccount" method="post"&gt; &lt;input type="hidden" name="id" value="1"/&gt; name:&lt;input type="text" name="name"/&gt;&lt;br&gt;&lt;br&gt; money:&lt;input type="text" name="money"/&gt;&lt;br&gt;&lt;br&gt; &lt;input type="submit" value="提交"/&gt;&lt;/form&gt; 注意 被@ModelAttribute注释的方法会在此controller每个方法执行前被执行，因此对于一个controller映射多个URL的用法来说，要谨慎使用。 七 处理数据模型 与传统的Servlet将数据放到request域通过转发带到jsp无异 (一) ModelAndView(二) ModelMap(三) Model(四) Map(五) 将数据放到session中 默认情况下Spring MVC将模型中的数据存储到request域中。当一个请求结束后，数据就失效了。如果要跨页面使用。那么需要使用到session。而@SessionAttributes注解就可以使得模型中的数据存储一份到session域中。 @SessionAttributes参数 names：这是一个字符串数组。里面应写需要存储到session中数据的名称。 types：根据指定参数的类型，将模型中对应类型的参数存储到session中 value：其实和names是一样的。 例：@SessionAttributes(types = {User.class}) 将所有User类型放到session中 如果想删除session中共享的参数，可以通过SessionStatus.setComplete()，这句只会删除通过@SessionAttribute保存到session中的参数 【注意】：@SessionAttributes注解只能在类上使用，不能在方法上使用 八 国际化(一). 编写properties文件 (二). xml配置123456789101112131415&lt;!-- 国际化 --&gt;&lt;bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource"&gt; &lt;property name="basename" value="i18n"&gt;&lt;/property&gt; &lt;property name="defaultEncoding" value="UTF-8"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- id不能不写 --&gt;&lt;bean id="localeResolver" class="org.springframework.web.servlet.i18n.CookieLocaleResolver"&gt;&lt;/bean&gt; &lt;!-- 该拦截器通过名为”lang”的参数来拦截HTTP请求，使其重新设置页面的区域化信息 --&gt;&lt;mvc:interceptors&gt; &lt;bean class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"&gt; &lt;property name="paramName" value="lang"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/mvc:interceptors&gt; (三). controller1234@RequestMapping(value = "lang")public String lang()&#123; return "index.jsp";&#125;]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在服务器(CentOS)上搭建Git]]></title>
    <url>%2F2019%2F06%2F30%2F%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8(CentOS)%E4%B8%8A%E6%90%AD%E5%BB%BAGit%2F</url>
    <content type="text"><![CDATA[假装已经安装好Git，建好了组和用户… 一 搭建git代码仓库(一) 新建git仓库(仓库位置自己随用户自己决定，例/home/git/test.git) 在/home/git目录下新建 项目名称test.git 文件夹 cd /home/git/test.git 进入文件夹。 git init –bare 创建裸库(这里需要注意–bare参数，表示是要生成一个”干净”的仓库) 修改权限1234# chown -R liyuqing:git gittest // liyuqing:用户名 git:组名# chmod -R 775 gittest# chmod g+s -R gittest# sudo chown -R liyuqing:git gittest (二) 创建证书登录添加证书之前，还要做这么一步：Git服务器打开RSA认证 。在Git服务器上首先需要将/etc/ssh/sshd_config中的RSA认证打开，即将sshd_config文件中下面几个的注释解开： 1.RSAAuthentication yes 2.PubkeyAuthentication yes 3.AuthorizedKeysFile .ssh/authorized_keys 保存后，systemctl restart sshd 生效 (三) 配置ssh公钥（无需密码更新代码库）1. 生成 SSH 公钥 每个需要使用git仓库的软件开发者，需要在使用git代码库的电脑上面生成一个ssh公钥，具体步骤： 进入自己的~/.ssh目录(win系统在用户文件夹下：C:\Users\Administrator.ssh)，查看有没有用 文件名 和 文件名.pub 来命名的一对文件，这个 文件名 通常是 id_dsa 或者 id_rsa。 *.pub 文件是公钥，另一个文件是密钥。假如没有这些文件（或者干脆连 .ssh 目录都没有），在linux下，你可以用 ssh-keygen 的程序来建立它们，该程序在 Linux/Mac 系统由 SSH 包提供； 在 Windows 上则包含在 MSysGit 包里，git安装目录中，bin路径下ssh-keygen.exe。 运行后，它先要求你确认保存公钥的位置（.ssh/id_rsa），然后它会让你重复一个密码两次，如果不想在使用公钥的时候输入密码，可以留空。 复制本机的*.pub中的内容添加至git仓库所在服务器的git用户文件夹下的/home/git/.ssh/authorized_keys文件中 可使用命令# $ cat /tmp/id_rsa.john.pub &gt;&gt; ~/.ssh/authorized_keys，将公钥内容追加至授权文件中。 如果 ~/.ssh/authorized_keys 不存在，你可以直接将id_rsa.pub 文件复制过去并重命名为authorized_keys即可 (四) 访问使用正确的地址 例如：我在 /usr下建立了名为gittest文件夹并将其作为一个仓库，那么我访问的地址就应该是： 1用户名@服务器ip:/usr/gittest 二 使用过程中出现的问题(一) git push的问题1. 报错remote: error: refusing to update checked out branch… ：12345678910111213141516remote: error: refusing to update checked out branch: refs/heads/masterremote: error: By default, updating the current branch in a non-bare repositoryremote: error: is denied, because it will make the index and work tree inconsistentremote: error: with what you pushed, and will require &apos;git reset --hard&apos; to matchremote: error: the work tree to HEAD.remote: error:remote: error: You can set &apos;receive.denyCurrentBranch&apos; configuration variable toremote: error: &apos;ignore&apos; or &apos;warn&apos; in the remote repository to allow pushing intoremote: error: its current branch; however, this is not recommended unless youremote: error: arranged to update its work tree to match what you pushed in someremote: error: other way.remote: error:remote: error: To squelch this message and still keep the default behaviour, setremote: error: &apos;receive.denyCurrentBranch&apos; configuration variable to &apos;refuse&apos;.To 47.100.165.17:/usr/hexo/myblog/source ! [remote rejected] master -&gt; master (branch is currently checked out) 这是因为git默认是拒绝push操作的，我们在.git/config里面添加如下配置项即可：12[receive] denyCurrentBranch = ignore 添加完成之后执行代码git config receive.denyCurrentBranch ignore 2. 报错remote: error: insufficient permission… :1remote: error: insufficient permission for adding an object to repository database ./objects 没有权限的问题 这是当我们初始化一个远程仓库的时候，使用git –bare init即可了，而不是使用git init，这样那么该远程仓库的目录下，也包含work tree，当本地仓库向远程仓库push时，如果远程仓库正在push的分支上时，那么push后的结果不会反映在work tree上，也就是在远程仓库的目录下对应的文件还是之前的内容，必须使用git reset –hard才能看到push之后的内容。 (二) git pull的问题git pull 失败 ,提示： fatal: refusing to merge unrelated histories 其实这个问题是因为 两个 根本不相干的 git 库， 一个是本地库， 一个是远端库， 然后本地要去推送到远端， 远端觉得这个本地库跟自己不相干， 所以告知无法合并。 使用这个强制的方法： git pull origin master --allow-unrelated-histories (三) 关于push成功服务器上的内容没有改变 在远程创库执行以下命令，才可以看到更新的内容。12git config --unset core.bare 首次执行git reset --hard git config –bool core.bare true]]></content>
      <tags>
        <tag>Centos7</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用chrome将网页保存为单网页(mhtml)]]></title>
    <url>%2F2019%2F06%2F02%2F%E4%BD%BF%E7%94%A8chrome%E5%B0%86%E7%BD%91%E9%A1%B5%E4%BF%9D%E5%AD%98%E4%B8%BA%E5%8D%95%E7%BD%91%E9%A1%B5-mhtml%2F</url>
    <content type="text"><![CDATA[使用chrome将网页保存为单网页(mhtml)chrome默认是没有开启网页另存为mhtml这个选项的，所以便需要我们收动开启。 在地址栏输入 chrome://flags/ 进入这个所谓Experiments的设置页 Crtl + F 搜索html,讲这个启用保存为mhtml的开关打开，如下图所示。这样在保存网页，就可以选择mhtml格式了。 2019年9月7日 22:41:48 PS: 额，这篇文章写于19年6月份，但是在随后chrome的更新中，这个设置好像就找不到了，所以通过浏览器本身来保存单页面是不可以了😅，不过笔者随后在chrome插件商店上找到了一个叫做SingleFile用来保存单网页的插件，功能倒是挺丰富的，用起来也很不错。地址：https://chrome.google.com/webstore/detail/singlefile/mpiodijhokgodhhofbcjdecpffjipkle?utm_source=chrome-ntp-icon]]></content>
  </entry>
  <entry>
    <title><![CDATA[普通Java项目读取properties文件]]></title>
    <url>%2F2019%2F05%2F25%2F%E6%99%AE%E9%80%9AJava%E9%A1%B9%E7%9B%AE%E8%AF%BB%E5%8F%96properties%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[后缀properties是一种属性文件。这种文件以key=value格式存储内容。Java中可以使用Properties类来读取这个文件。String value=p.getProperty(key);就能得到对应的数据。一般这个文件作为一些参数的存储，代码就可以灵活一点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package priv.lyq.test;import java.io.IOException;import java.io.InputStream;import java.util.Properties;import javax.xml.transform.Source;import org.junit.jupiter.api.Test;import com.sun.org.apache.xalan.internal.xsltc.compiler.SourceLoader;public class ReadProperties &#123; @Test public void test1() &#123; Properties pop = new Properties(); /* InputStream input=new FileInputStream(new File(pathfileName));*/ // 绝对路径 InputStream input = Thread.currentThread().getContextClassLoader().getResourceAsStream("db.properties"); try &#123; pop.load(input); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(pop.get("driver")); System.out.println(pop.get("url")); System.out.println(pop.get("username")); System.out.println(pop.get("password")); &#125; &#125; @Test public void test2() &#123; Properties pop = new Properties(); // InputStream input = SourceLoader.class.getResourceAsStream("db.properties"); InputStream input = ClassLoader.getSystemResourceAsStream("db.properties"); try &#123; pop.load(input); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(pop.get("driver")); System.out.println(pop.get("url")); System.out.println(pop.get("username")); System.out.println(pop.get("password")); &#125; &#125; /*end*/&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL57报错：Host 'localhost' is not allowed to connect to this MySQL server]]></title>
    <url>%2F2019%2F05%2F23%2FMySQL57%E6%8A%A5%E9%94%99%EF%BC%9AHost-localhost-is-not-allowed-to-connect-to-this-MySQL-server%2F</url>
    <content type="text"><![CDATA[打开my.ini（通常在C:\ProgramData\MySQL\MySQL Server 5.7 *该文件夹是默认隐藏的 *） 在[mysqld]下加下面两行：12skip-name-resolveskip-grant-tables]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Commons Codec基本使用]]></title>
    <url>%2F2019%2F05%2F23%2FCommons-Codec%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在实际的应用中，我们经常需要对字符串进行编解码，Apache Commons家族中的Commons Codec就提供了一些公共的编解码实现，比如Base64, Hex, MD5,Phonetic and URLs等等。 Base64编解码123456789101112131415161718private static String encodeTest(String str)&#123; Base64 base64 = new Base64(); try &#123; str = base64.encodeToString(str.getBytes("UTF-8")); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; System.out.println("Base64 编码后："+str); return str;&#125; private static void decodeTest(String str)&#123; Base64 base64 = new Base64(); // str = Arrays.toString(Base64.decodeBase64(str)); str = new String(Base64.decodeBase64(str)); System.out.println("Base64 解码后："+str);&#125; Hex编解码123456789101112131415161718192021private static String encodeHexTest(String str)&#123; try &#123; str = Hex.encodeHexString(str.getBytes("UTF-8")); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; System.out.println("Hex 编码后："+str); return str;&#125; private static String decodeHexTest(String str)&#123; Hex hex = new Hex(); try &#123; str = new String((byte[])hex.decode(str)); &#125; catch (DecoderException e) &#123; e.printStackTrace(); &#125; System.out.println("Hex 编码后："+str); return str;&#125; MD5加密12345678private static String MD5Test(String str)&#123; try &#123; System.out.println("MD5 编码后："+newString(DigestUtils.md5Hex(str.getBytes("UTF-8")))); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return str;&#125; SHA编码12345678private static String ShaTest(String str)&#123; try &#123; System.out.println(“SHA 编码后：”+newString(DigestUtils.shaHex(str.getBytes("UTF-8")))); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return str;&#125; Metaphone和Soundex 这个例子来源于网上，网址见：http://350129923.blog.163.com/blog/static/17959113200763144659125/ Metaphone 建立出相同的key给发音相似的单字, 比 Soundex 还要准确, 但是 Metaphone 没有固定长度, Soundex 则是固定第一个英文字加上3个数字. 这通常是用在类似音比对, 也可以用在 MP3 的软件开发. 123456789101112131415161718192021222324252627282930313233import org.apache.commons.codec.language.*;import org.apache.commons.codec.*;public class LanguageTest &#123; public static void main(String args[]) &#123; Metaphone metaphone = new Metaphone(); RefinedSoundex refinedSoundex = new RefinedSoundex(); Soundex soundex = new Soundex(); for (int i = 0; i &lt; 2; i++) &#123; String str = (i == 0) ? "resume" : "resin"; String mString = null; String rString = null; String sString = null; try &#123; mString = metaphone.encode(str); rString = refinedSoundex.encode(str); sString = soundex.encode(str); &#125; catch (Exception ex) &#123; ; &#125; System.out.println("Original:" + str); System.out.println("Metaphone:" + mString); System.out.println("RefinedSoundex:" + rString); System.out.println("Soundex:" + sString + "\\n"); &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git的一些操作]]></title>
    <url>%2F2019%2F05%2F12%2FGit%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[删除Git本地仓库 找到本地仓库的目录，在git的命令窗口打开 $ rm -rf .git &nbsp;&nbsp;&nbsp;&nbsp; 删除 .git 文件夹 重命名文件12git mv file_name new_file_namegit commit -m&apos;添加注释&apos; 删除GitHub上的某个文件夹 找个文件夹把项目从github上克隆下来 把项目在Git的窗口里打开 输入命令 1git rm -r --cached 文件夹名 提交并写上日志 1git commit -m &apos;删除了xxx&apos; 最后上传到 github OK! 1git push // 上传 拉取同步1git pull]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改VS Code(即emmet语法)自动生成的HTML模板]]></title>
    <url>%2F2019%2F04%2F27%2F%E4%BF%AE%E6%94%B9VS-Code-%E5%8D%B3emmet%E8%AF%AD%E6%B3%95-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84HTML%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[修改VS Code(即emmet语法)自动生成的HTML5模板 在对emmet配置文件修改前，请务必备份，以防万一。修改emmet配件文件需要关闭VSCode并重新打开方可生效。将H5模板的lang属性值修改成zh-CN/zh-cmn-Hans 找到下面的文件1&#123;VSC安装路径&#125;\resources\app\extensions\emmet\node_modules\vscode-emmet-helper\out\expand\expand-full.js 使用notepad或VSC打开它，搜索defaultVariables，在第1个搜索结果中，即可看到关于lang: ‘en’的描述，将其中的en替换成zh-cmn-Hans并保存即可。1defaultVariables = &#123; lang: 'en', locale: 'en-US', charset: 'UTF-8' &#125;。 修改H5模板生成时光标的初始位置 默认情况下，使用！感叹号生成H5模板时，光标默认是选中device-width文本状态，需要3-4个Tab键才能将光标移入body中。打开xpand-full.js，搜索关键字device-width即可找到如下代码： 12"meta:vp": "meta[name=viewport content='width=$&#123;1:device-width&#125;, initial-scale=$&#123;2:1.0&#125;']","meta:edge": "meta:compat[content='$&#123;1:ie=edge&#125;']", 上面$大括号中的1:， 2:便是锁定光标的顺序，所以只要删除1: ,2:就行了，但是这样在生成html是她的属性值就变成了${device-width}、${ie=edge}，所以干脆把$和大括号也删掉就好了。 VSCode下emmet生成H5模板的简单总结 expand-full.js文件是emmet在VSCode的全局配件文件。再提醒一次，修改之前请务必备份之，以防不测。 英文状态下的!(感叹号)可触发emmet的H5模板。使用VSC打开expand-full.js文件，定位于5100行。大概有3行代码(逗号分隔)，如下123"!!!": "&#123;&lt;!DOCTYPE html&gt;&#125;", "doc": "html[lang=$&#123;lang&#125;]&gt;(head&gt;meta[charset=$&#123;charset&#125;]+meta:vp+meta:edge+title&#123;$&#123;1:Document&#125;&#125;)+body", "!|html:5": "!!!+doc", 第1行的代码的意思大概就是使用3个!即可自动补全第3行代码的意思是键1个!即可调第1行的补全功能及第2行的补全功能。重点是第2行代码，${lang}的意思应该是寻找关于lang的变量，我估计直接将常量lang=”zh-CN”写死在此处是可行的。${charset}同理可证。meta:vp将会调用4986行处的代码块，这个块里使用1:及2:依次控制着2个光标选中状态，建议清除1:和2:和包裹它们的$及对应的{}。meta:edge同理可证。title{${1:Document}}，其中title即为H5模板的页面标题，$应该是类似于变量的引用，1:还是意味着初始时光标在标题行的第1次选中Document文本状态，后者也就是模板页面的标题，完全可以修改成自己想要字符。 完成修改后，H5模板初始时，光标是L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false}});之间，减少了不必要的干扰，lang的属性值是zh-cmn-Hans，减少了某些浏览器集成语言检测的干扰，还可以将缺省的标题修改成自己的个性文字。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="zh-cmn-Hans"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge,chrome=1"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;charset="UTF-8"的修改应该是在&#123;VSCode安装路径&#125;\resources\app\extensions\html\snippets\html.snippets.json文件中进行。]]></content>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL执行sql语句报错"[Err] 1055 - Expression \#1 of ORDER BY... GROUP BY clause and]]></title>
    <url>%2F2019%2F04%2F07%2FMySQL%E6%89%A7%E8%A1%8Csql%E8%AF%AD%E5%8F%A5%E6%8A%A5%E9%94%99%5BErr%5D%201055%2F</url>
    <content type="text"><![CDATA[查看下SQL的模式 1SHOW VARIABLES LIKE &apos;%sql_mode%&apos;; 查看下SQL的模式,非必须 修改sql_mode的值 12set sql_mode = &apos;&apos;;set sql_mode = &apos;NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES&apos;; 再次执行刚才的语句，就不会报错了。 或者执行:12select version(),@@sql_mode;SET sql_mode=(SELECT REPLACE(@@sql_mode,&apos;ONLY_FULL_GROUP_BY&apos;,&apos;&apos;)); 这里我并没有深入研究，姑且先知道这样做能解决问题罢了。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[去除WinRAR的弹窗广告]]></title>
    <url>%2F2019%2F04%2F04%2F%E5%8E%BB%E9%99%A4WinRAR%E7%9A%84%E5%BC%B9%E7%AA%97%E5%B9%BF%E5%91%8A%2F</url>
    <content type="text"><![CDATA[电脑桌面新建一个txt文件，重命名为“rarreg.key” 将.key文件用记事本方式打开，将一下的内容复制粘贴到文本中并保存 1234567891011RAR registration dataFederal Agency for Education1000000 PC usage licenseUID=b621cca9a84bc5deffbf6412612250ffbf533df6db2dfe8ccc3aae5362c06d54762105357d5e3b1489e751c76bf6e0640001014be50a52303fed29664b0741457e567d04159ad8defc3fb6edf32831fd1966f72c21c0c53c02fbbb2f91cfca671d9c482b11b8ac3281cb21378e85606494da349941fae9ee328f12dc73e90b6356b921fbfb8522d6562a6a4b97e8ef6c9ffb866be1e3826b5aa126a4d2bfe9336ad63003fc0e71c307fc2c6064416495d4c55a0cc82d402110498da970812063934815d81470829275 将该文件复制粘贴到winrar压缩软件安装路径下，替换原文件 (如果系统提示存在同名文件的话) 下载resource hacker，安装版或者绿色版的都行，下载安装完之后先关闭winrar 下载链接：https://pan.baidu.com/s/1F4EeXwxCoYGlvXXjxDU7Cw 提取码：c00x 打开resource hacker，点左上角的“文件”，选择winrar安装目录下的winrar.exe，双击打开后在左边找到“字符串表”——&gt; 80: 按键盘上的delete删除右边字符串里面“1272”最长的一行（不一定是1272，但就是各种符号组合最长的那一串），点击上面绿色的三角编译脚本，然后左上角的“文件”——“另存为”，将反编译好的winrar.exe文件保存在电脑的任意位置 (方便你找到的位置就可以，但不能直接保存在winrar安装目录下) 把刚才保存的.exe文件复制或剪切到winrar的安装目录下，替换原文件就OK了~]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo底部添加备案信息]]></title>
    <url>%2F2019%2F04%2F03%2FHexo%E5%BA%95%E9%83%A8%E6%B7%BB%E5%8A%A0%E5%A4%87%E6%A1%88%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[在所使用主题文件夹下的 /layout/_partial 编辑 footer.swig 在如下位置添加： 根据自己的备案号进行修改 123456&lt;span&gt; &lt;/br&gt; &#123;&#123; __(&apos;豫ICP备&apos;) &#125;&#125; - &lt;a href=&quot;http://www.miitbeian.gov.cn/&quot;&gt;18035862号-1&lt;/a&gt; &lt;/a&gt;&lt;/span&gt; 保存，hexo clean hexo g ,效果如下：]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[访问hexo admin]]></title>
    <url>%2F2019%2F04%2F02%2F%E8%AE%BF%E9%97%AEhexo-admin%2F</url>
    <content type="text"><![CDATA[nginx管理了hexo的public目录后，再给hexo开放一个其他的端口供其使用，然后就可以一边用nginx的代理一边使用hexo admin]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用UltraISO（软碟通）制作u盘启动盘]]></title>
    <url>%2F2019%2F03%2F09%2F%E4%BD%BF%E7%94%A8UltraISO%EF%BC%88%E8%BD%AF%E7%A2%9F%E9%80%9A%EF%BC%89%E5%88%B6%E4%BD%9Cu%E7%9B%98%E5%90%AF%E5%8A%A8%E7%9B%98%2F</url>
    <content type="text"><![CDATA[首先我们先安装软碟通，完成安装后打开软碟通，文件-&gt;打开，打开我们的iso镜像。 然后选择我们的U盘,然后点击启动-&gt;写入硬盘映像。 写入方式有zip和hdd两种，一般我们选择hdd或hdd+（这里就是默认的选择），选择了写入方式之后要先格式化（如果u盘开始前没有被格式化的话），格式化完毕之后点击写入等待写入完毕即可。 过程漫长，耐心等待。]]></content>
  </entry>
  <entry>
    <title><![CDATA[eclipse安装markdown插件]]></title>
    <url>%2F2019%2F03%2F07%2Feclipse%E5%AE%89%E8%A3%85markdown%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[进入help &gt; Install New Software 点击 add 在Locaton栏输入:1http://winterwell.com/software/updatesite/ 和平常安装eclipse插件一样，一路next最后重启一下就ok了。千万不要手残点Cancel，多少次安装插件就因为Cancel是默认选中的而手残点了一下，导致前功尽弃。 在Show View里吧 markdown的预览放到控制台就行了。]]></content>
      <tags>
        <tag>markdown</tag>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给hexo添加一些实用有趣的小功能]]></title>
    <url>%2F2019%2F02%2F16%2F%E7%BB%99hexo%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%94%A8%E6%9C%89%E8%B6%A3%E7%9A%84%E5%B0%8F%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[注意：以下功能是在NexT主题上实现的，有些功能是通用的，有些可能与其他主题有些出入。 添加网站网页访问浏览计数器 这里使用不蒜子网页计数器 进入你使用的主题的文件夹里，打开layout文件夹里的_layout.swig（不要使用记事本，找一个能选择编码格式的文本编辑器，这里使用Notepad++）,加入以下代码 1234&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;&lt;/br&gt;本站总访问量 &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; 次&amp;nbsp&amp;nbsp&amp;nbsp本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次 最后，注意一下 /layout/_third-party/analytics 里的 *busuanzi-counter.swig *文件，看看链接对不对。 1&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 添加点击页面出现的红心 进入你使用的主题的文件夹里，在 source/js/src 里创建一js文件，就命名为love.js(名字随意)吧。写入： 1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 打开layout文件夹里的_layout.swig,&lt;body&gt;标签最后添加： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 侧边栏社交小图标 打开主题配置文件_config.yml，搜索social:, || 之后是在图标库中对应的图标。注意空格。 主页文章加阴影 打开\themes\next\source\css_custom\custom.styl,向里面加入： 12345678// 主页文章添加阴影效果.post &#123;margin-top: 60px;margin-bottom: 60px;padding: 25px;-webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);-moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 侧边栏添加音乐播放使用网易云音乐的外链 访问 网易云音乐，找到想要使用的歌曲然后生成外链播放器。 将代码放到所用主题文件夹/layout/_macro下的sidebar.swig文件里。 网易云音乐的外链确实很方便，但是有一个问题就是版权！所以好多歌曲不能生成外链。So使用本地音乐 暂时不想写了，不过你可以访问上图框框里的地址，相信会有收获的。 添加Fork me on Github 在http://tholman.com/github-corners/ 或者 https://github.com/blog/273-github-ribbons 选择合适的样式复制代码。 到themes/next/layout/_layout.swig，将代码放到&lt;div class=”headband”&gt;下面： 注意划线部分代码，如果 github 标示不能正常显示在页面表层则添加 1z-index: 100; //z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。 然后可以通过定位进行微调。 增加打赏功能这个是在NexT主题上添加的 将支付宝、微信的收钱码图片上传到hexo的** source/images** 文件夹里。（额，最好用修图工具将两个图片的分辨率调一致，这样在页面上比较好看一点） 在 主题 配置文件_config.yml里添加如下内容： 1234#打赏 reward_comment: 喜欢文章就打赏一包辣条吧！alipay: /images/sqz.jpgwechatpay: /images/sqw.png 到这里就完成了，不过鼠标放到收钱码上文字会闪动，想要取消就： 修改next/source/css/_common/components/post/post-reward.styl ，注释掉下面的代码 123456789101112131415/* #wechat:hover p&#123;animation: roll 0.1s infinite linear;-webkit-animation: roll 0.1s infinite linear;-moz-animation: roll 0.1s infinite linear;&#125;#alipay:hover p&#123;animation: roll 0.1s infinite linear;-webkit-animation: roll 0.1s infinite linear;-moz-animation: roll 0.1s infinite linear;&#125;*/]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7安装node.js+pm2]]></title>
    <url>%2F2019%2F02%2F15%2FCentos7%E5%AE%89%E8%A3%85node.js%2Bpm2%2F</url>
    <content type="text"><![CDATA[Linux 上安装 Node.js直接使用已编译好的包Node 官网已经把 linux 下载版本更改为已编译好的版本了，我们可以直接下载解压后使用： wget https://nodejs.org/dist/v10.9.0/node-v10.9.0-linux-x64.tar.xz // 下载 tar xf node-v10.9.0-linux-x64.tar.xz // 解压 cd node-v10.9.0-linux-x64/ // 进入解压目录 ./bin/node -v // 执行node命令 查看版本v10.9.0 解压文件的 bin 目录底下包含了 node、npm 等命令，我们可以使用 ln 命令来设置软连接：ln -s /usr/software/nodejs/bin/npm /usr/local/bin/ln -s /usr/software/nodejs/bin/node /usr/local/bin/Ubuntu 源码安装 Node.js以下部分我们将介绍在 Ubuntu Linux 下使用源码安装 Node.js 。 其他的 Linux 系统，如 Centos 等类似如下安装步骤。在 Github 上获取 Node.js 源码：$ sudo git clone https://github.com/nodejs/node.gitCloning into ‘node’…修改目录权限：$ sudo chmod -R 755 node使用 ./configure 创建编译文件，并按照：$ cd node$ sudo ./configure$ sudo make$ sudo make install查看 node 版本：$ node –versionv0.10.25Ubuntu apt-get命令安装命令格式如下：sudo apt-get install nodejssudo apt-get install npmCentOS 下源码安装 Node.js1、下载源码，你需要在https://nodejs.org/en/download/下载最新的Nodejs版本，本文以v0.10.24为例:cd /usr/local/src/wget http://nodejs.org/dist/v0.10.24/node-v0.10.24.tar.gz2、解压源码tar zxvf node-v0.10.24.tar.gz3、 编译安装cd node-v0.10.24./configure –prefix=/usr/local/node/0.10.24makemake install4、 配置NODE_HOME，进入profile编辑环境变量vim /etc/profile设置 nodejs 环境变量，在 export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL 一行的上面添加如下内容: #set for nodejsexport NODE_HOME=/usr/local/node/0.10.24export PATH=$NODE_HOME/bin:$PATH:wq保存并退出，编译/etc/profile 使配置生效source /etc/profile验证是否安装配置成功node -v输出 v0.10.24 表示配置成功npm模块安装路径/usr/local/node/0.10.24/lib/node_modules/注：Nodejs 官网提供了编译好的 Linux 二进制包，你也可以下载下来直接应用。 npm install -g pm2 whereis pm2pm2: /opt/nodejs/bin/pm2 sudo ln -s /opt/nodejs/bin/pm2 /usr/bin/pm2 sudo ln -s /usr/node/node-v10.15.1-linux-x64/bin/pm2 /usr/bin/pm2]]></content>
  </entry>
  <entry>
    <title><![CDATA[Markdown基本语法]]></title>
    <url>%2F2019%2F02%2F13%2FMarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[标题使用“#”加空格在行首来创建标题 123# 一级标题## 二级标题### 三级标题 字体 加粗文本两端用两个星号或者两个下划线包裹 斜体文本两端用一个星号或者一个下划线包裹 斜体加粗文本两端用三个星号或者三个下划线包裹 删除线文本两端用两个~~包裹 1234**这是加粗的文字**_这是斜体的文字_***这是斜体加粗的文字***~~这是有删除线的文字~~ 例如:这是加粗的文字这是斜体的文字这是斜体加粗的文字这是有删除线的文字 居中使用html语法&lt;center&gt;需要居中的文字&lt;/center&gt;例如：需要居中的文字 引用使用“&gt;”在段首来引用一段文字 1&gt;这是一段引用 例如: 这是一段引用 无序列表使用“-”、“*”或“+”加空格来创建无序列表 123- 这是一个无序列表* 这是一个无序列表+ 这是一个无序列表 例如: 这是一个无序列表 这是一个无序列表 这是一个无序列表 有序列表使用数字圆点加空格如“1. ”、“2. ”来创建有序列表 1231. 这是一个有序列表2. 这是一个有序列表3. 这是一个有序列表 例如: 这是一个有序列表 这是一个有序列表 这是一个有序列表分割线三个或者三个以上的 - 或者 * 都可以 12___****** 例如: 未完待续...]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos系统下各文件夹的作用]]></title>
    <url>%2F2019%2F02%2F13%2FCentOS%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%90%84%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[/bin 二进制可执行命令/dev 设备特殊文件/etc 系统管理和配置文件/etc/rc.d 启动的配置文件和脚本 /home 用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示/lib 标准程序设计库，又叫动态链接共享库，作用类似windows里的.dll文件/sbin 系统管理命令，这里存放的是系统管理员使用的管理程序/tmp 公用的临时文件存储点/root 系统管理员的主目录（呵呵，特权阶级）/mnt 系统提供这个目录是让用户临时挂载其他的文件系统。/lost+found 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里/proc 虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。/var 某些大文件的溢出区，比方说各种服务的日志文件/usr 最庞大的目录，要用到的应用程序和文件几乎都在这个目录。其中包含：/usr/x11r6 存放x window的目录/usr/bin 众多的应用程序/usr/sbin 超级用户的一些管理程序/usr/doc linux文档/usr/include linux下开发和编译应用程序所需要的头文件/usr/lib 常用的动态链接库和软件包的配置文件/usr/man 帮助文档/usr/src 源代码，linux内核的源代码就放在/usr/src/linux里/usr/local/bin 本地增加的命令/usr/local/lib 本地增加的库]]></content>
      <tags>
        <tag>Centos7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7安装高版本git]]></title>
    <url>%2F2019%2F02%2F11%2FCentos7%E5%AE%89%E8%A3%85%E9%AB%98%E7%89%88%E6%9C%ACGit%2F</url>
    <content type="text"><![CDATA[使用命令* git –version * 查看系统是否已经安装git,而且多是1.8版本的git（使用 yum install -y git 安装git也是1.8的版本）,不过这个版本可能有些低，所以需要手动安装较高的的版本。 步骤 使用命令 * yum remove git * 移除旧版本。 可以访问 mirrors.edge.kernel.org/pub/software/scm/git/ 来查看选择或者下载git的各个版本。 安装git的依赖库 12yum install curl-devel expat-devel gettext-devel openssl-devel zlib-deveyum install gcc perl-ExtUtils-MakeMaker 下载高版本git使用wget（一个从网络上自动下载文件的自由工具)，或者直接从上述网站上下载好上传到服务器。 1wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.9.5.tar.gz 解压，然后进入解压后的文件夹 1tar -zxvf git-2.9.5.tar.gz 编译安装，配置 12./configure --prefix=/usr/local/git make &amp; make install 设置环境变量 123echo &quot;export PATH=$PATH:/usr/local/git/bin&quot;&gt;&gt;/etc/bashrcsource /etc/bashrcgit --version 如果查看版本是1.8的话，你可以卸载了它，然后重新生效下环境变量就可以了。 123sudo yum remove gitsource /etc/bashrcgit --version]]></content>
      <tags>
        <tag>Centos7</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7安装netstat]]></title>
    <url>%2F2019%2F02%2F09%2FCentos7%E4%B8%8B%E5%AE%89%E8%A3%85netstat%2F</url>
    <content type="text"><![CDATA[yum install net-tools 查看端口：* netstat -ntlp *]]></content>
      <tags>
        <tag>Centos7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMware中Centos7的联网]]></title>
    <url>%2F2019%2F02%2F09%2FVMware%E4%B8%ADCentos7%E7%9A%84%E8%81%94%E7%BD%91%2F</url>
    <content type="text"><![CDATA[VMware的设置 首先：打开虚拟机的编辑菜单，选择“虚拟机网络编辑器”，点击更改设置 在虚拟机网络编辑器中选择还原默认设置 Linux的设置在这里需要注意的是必需以root用户来登录进行设置 输入 ls /etc/sysconfig/network-scripts，查看该虚拟机的网络信息。 接着在终端输入vi /etc/sysconfig/network-scripts/ifcfg-ensXXXX，此时进入ifcfg-ensXXXX这个网络配置文件的阅读模式。 接着按i键，进入文本插入编辑模式，重点设置BOOTPROTO=dhcp，ONBOOT=yes即可。 修改完之后，先按Esc键，再输入 :wq ，最后按回车键方可退出vim编辑器。 开启VMware相关服务 新建一个bat文件，输入：123net start &quot;VMware DHCP Service&quot;net start &quot;VMware NAT Service&quot;pause 以管理员身份运行。 虚拟机的终端中输入 service network restart，回车确认重启network服务。 使用 ping 命令或者 ping -c 数字 测试是否能联网]]></content>
      <tags>
        <tag>Centos7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo搭建个人博客]]></title>
    <url>%2F2019%2F02%2F02%2F%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[测试使用hexo的第一篇文章hexo-admin 引用内容 12代码块alert(&apos;Hello World!&apos;); 图片的引用source/images引用资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于 ** - !&#91;&#93;&#40;images/img.jpg&#41; ** 的方法访问它们。 相对路径的引用 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true。 在你的hexo目录下执行这样一句话npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件。 等待一小段时间后，再运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 （当然也可以自己手动建） 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：!&#91;你想输入的替代文字&#93;(xxxx/图片名.jpg)。 注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。 最后检查一下，hexo g生成页面后，进入public\2017\02\26\index.html文件中查看相关字段，可以发现，html标签内的语句是&lt;img src=”2017/02/26/xxxx/图片名.jpg”&gt;，而不是&lt;img src=”xxxx/图片名.jpg&gt;。这很重要，关乎你的网页是否可以真正加载你想插入的图片。 使用 MarkDown 语法添加图片 !&#91;lbj&#93;&#40;使用hexo搭建个人博客/LBJ001.jpg&#41; 2019年7月6日 21:41:01补充ps:之前在服务器上使用MarkDown一直是（文章文件夹名/图片名.png）这种标准的格式。图片链接是这样的: localhost:4000/2019/02/02/使用hexo搭建个人博客/LBJ001.jpg但是我在windows使用hexo链接却变成了localhost:4000/2019/02/02/使用hexo搭建个人博客/使用hexo搭建个人博客/LBJ001.jpg 所以只能是去掉文章文件夹名直接写图片名。 也就是!&#91;lbj&#93;&#40;使用hexo搭建个人博客/LBJ001.jpg）变成 !&#91;lbj&#93;&#40;LBJ001.jpg) 在编辑器写上图片所在文件名才是对的，这样才能读取，但是hexo对于md语法给自动添加了，这实在是画蛇添足。 可以看出一个变成了相对路径，一个变成了绝对路径。 使用 hexo 语法添加图片* &#123;%&nbsp;asset_img LBJ001.jpg&nbsp;%&#125;]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
